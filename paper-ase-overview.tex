\section{Athletic software engineering in a nutshell}

To understand what makes our approach ``athletic'', it helps to first consider some common approaches to software engineering education. 

{\em Lecture-based survey.}  One traditional software engineering educational model involves the study of an Introduction to Software Engineering textbook, with lectures presenting material from various chapters, and tests that assess the ability of students to define or manipulate concepts such as the ``Spiral Model'', ``White Box Testing'', ``Extreme Programming'', etc. This approach has the benefit of being both comprehensive and consistent in the way students each semester encounter the material. However, it treats software engineering material at a conceptual level and is the most susceptible to decreased learning through distraction.

{\em Project-based practicum.}  This approach involves solicitation of ```real-world'' application requirements from the surrounding community.  Students form teams and attempt to build software to satisfy their customer needs.  The project-based practicum tends to produce more engagement among many students, although the experiences encountered by each group varies a great deal based upon their community sponsor. In addition, the experience of a student within a single group can vary, and it is difficult to guarantee or assess that all students in the group are gaining the same software engineering experiences. 

{\em Flipped classroom.}  A third approach is to ``flip'' or ``invert'' the classroom. In this case, lecture material is recorded and provided to students via YouTube, leaving class time for more active learning opportunities. For example, class time can be devoted to what was traditionally ``homework'', which is how this approach became known as ``flipping''.  This approach requires students to focus on videos outside of class, which is highly susceptible to distraction.

Each of these approaches has their potential use cases, but none attempts to {\em explicitly} address the problems of distraction in modern educational environments. Put another way, how can we design the educational process to incentivize students to focus single-mindedly on the learning of complex, multi-step tasks without multi-tasking?  And if we can succeed, does that lead to more efficient and effective learning, which means that students will acquire more information in a given semester and retain it longer? 

Our approach adapts two simple features of conventional athletic training. First, time must be minimized.  Many sports (such as running, cycling, etc.) are based upon completing a task in a minimal amount of time.  Second, speed is a result of quality. To go fast, you must have good form and technique. 

Neither of these are traditionally applied to the software engineering classroom. In general, assignments are typically given out to remove time as an issue: for example, if the instructor believes a problem could be completed in a day, they might provide a week so that time is removed as a factor.  Second, working ``fast'' in software development is generally perceived as producing low quality software. Unlike athletic contexts, where fast means optimal technique, in software development, fast means sloppy technique. 

In athletic software engineering education, the goal is to produce {\em fluency} with languages, tools, and procedures, and fluency is measured by time to completion. For example, let's say we want to teach students to be able to create unit tests using JUnit for Java abstract data types in the IntelliJ IDEA interactive development environment for source code stored in GitHub. To accomplish this task fluently, the student must have obtained a sufficient level of fluency with its components: with the Java programming language, with the JUnit library, with the IntelliJ IDEA development environment, with the git distributed version control tool, and with the GitHub cloud service. 








