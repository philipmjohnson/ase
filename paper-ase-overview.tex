\section{Athletic software engineering in a nutshell}

To understand what makes our approach ``athletic'', it helps to first consider some common alternatives to software engineering education. 

{\em Lecture-based survey.}  One traditional educational model involves the use of one of the many high quality Introduction to Software Engineering textbooks, with lectures presenting material from various chapters, and tests that assess the ability of students to define or manipulate software engineering concepts such as the ``Spiral Model'', ``White Box Testing'', ``Extreme Programming'', etc. This approach has the benefit of being both comprehensive and consistent in the way students each semester encounter the material. However, it treats software engineering material at a conceptual level and the learning process is quite susceptible to modern technological distraction.

{\em Project-based practicum.}  This approach involves solicitation of ```real-world'' application requirements from the surrounding community.  Students form teams and attempt to build software to satisfy their customer needs.  The project-based practicum tends to produce more engagement among many students, although the experiences encountered by each group varies a great deal based upon their community sponsor. In addition, the experience of a student within a single group can vary, and it is difficult to guarantee or assess that all students in the group are gaining the same software engineering experiences. The instructor must somehow find a balance between micro-managing the teams to ensure a successful outcome, or else let them learn their lessons the hard way (``This is what happens when you wait until the last minute!'')

{\em Flipped classroom.}  A third approach is to ``flip'' or ``invert'' the classroom. In this case, lecture material is recorded and provided to students via YouTube, leaving class time for more active learning opportunities. For example, class time can be devoted to what was traditionally ``homework'', which is why this approach is known as ``flipped''.  This approach requires students to focus on videos outside of class, which is highly susceptible to distraction.

Each of these approaches has their potential use cases, and aspects of each can be blended into a single course, but none attempts to {\em explicitly} address the problems of distraction in modern educational environments. Put another way, how can we design the educational process to incentivize students to focus single-mindedly on the learning of complex, multi-step tasks without multi-tasking?  And if we can succeed, does that lead to more efficient and effective learning, which means that students will acquire more information in a given semester and retain it longer? 

Athletic software engineering education attempts to answer these questions by adopting two simple features of conventional athletic training. First, the primary goal is to minimize elapsed time.  Many sports (such as running, cycling, etc.) are based upon completing a task in a minimal amount of time.  Second, minimum elapsed time results from high quality effort. To go fast, you must have good form and technique. 

Neither of these features are typically present in the software engineering classroom. First, assignments are generally structured to {\em eliminate} time as a constraint: for example, if the instructor believes a problem could be completed in a day, they might provide a week.  This prevents students from ever claiming that they ``didn't have enough time to finish''.  Second, in software engineering, working ``fast'' is generally viewed as working ``sloppy''.  This is in direct contrast to athletic endeavors, where sloppiness generally produces slowness.

Athletic software engineering education resolves this dichotomy by differentiating between the creative aspects and the mechanics of each software engineering skill to be taught. Almost by definition, it is impossible to define the ``minimal'' time for the creative part. However, as we have discovered, it is straightforward to specify a reasonable minimal time for the ``mechanics'', and that this creates an educationally interesting opening for application of athletic concepts. 

Let's take a simple example: writing a unit test.  In a lecture-based survey course, students might read a chapter about unit testing and learn how to compare and contrast it with other kinds of testing (integration testing, load testing, etc.). The instructor might require students to demonstrate the ability to express this conceptual knowledge on a written exam.  

In a project-based practicum, students might be required to develop unit tests for their application. Different groups might develop their tests at different times and with different technologies. 

In a flipped classroom, students might learn about unit testing through video lectures at home, then come into class and develop a few unit tests under the guidance of the instructor. 

In athletic software engineering education, the writing of a unit test combines creative decisions (deciding what to test and why) and mechanics (the set of tasks to reify those decisions in high quality software).  In the first author's recent software engineering class, the mechanics involved testing a Java abstract data type using the JUnit library with code edited using the IntelliJ IDEA interactive development environment. Adherence to coding standards is verified by Checkstyle, and the completed unit test is stored in a GitHub repository. 

More specifically, mastering the mechanics of unit testing means the student can efficiently: sync their local repo with GitHub; create a local branch to hold their unit test development code; use IDEA shortcuts to create the Java class to hold the unit test and automatically import the appropriate JUnit library; apply refactoring if needed to extract a method for testing; use method completion to reduce the keystrokes required to create assertions; invoke the unit test within IDE; invoke Checkstyle to verify coding standards and fix any errors that occur; commit the finished code to the branch; and merge the branch into master. 

As you can see, the mechanics involved with developing even a simple unit test involves an interplay between six languages, tools, and technologies (Java, JUnit, IntelliJ IDEA, git, GitHub, and Checkstyle). And, as we have discovered, students can be incapable of developing unit tests, or take an excessive time to do so, not because of the creative decisions, but simply because they do not have mastery of the mechanics and no amount of googling can rescue them.

The good news is that by integrating athletic concepts into the curriculum, students can not only gain mastery of these mechanics, they can gain this mastery in a way that also overcomes the lure of technological distraction!  In a nutshell, athletic software engineering education involves the following:

\begin{enumerate}

\item {\bf Structure the curriculum as a sequence of skills to be mastered, not as concepts to be memorized.} While it is important, for example, for students to understand the conceptual difference between unit testing and load testing, athletic software engineeering focuses on skills (i.e. mechanics) whose acquisition can be demonstrated via the solving of problems whose minimal time to solution is between 5 and 20 minutes.  One of our courses teaches software engineering concepts through two tier web application development, with approximately a dozen ``skills'' each taking approximately a week to cover.

\item {\bf Create a set of ``training problems'' for each skill, each accompanied by a video that demonstrates their solution in ``optimal'' time.} Once a skill has been identified, the instructor provides background readings about the skill.  More importantly, the instructor also provides sample problems whose resolution requires use of the skill, along with an online video (typically YouTube) that shows a timed, ``reference solution'' for the problem. The video solution time becomes the operational definition of ``minimal'' time (we call it ``Rx'' time) to solve that problem. For example, the Rx time for one of our unit testing sample problems is 15 minutes. In addition to Rx time, we also provide a ``DNF'' (Do Not Finish) time, which indicates the maximal amount of time to spend solving the problem before we recommend they simply start over. For the unit testing problems, DNF time was 20 minutes. 

\item {\bf Provide time to learn to solve the training problems in Rx time.} Given the background readings and the sample problems, the students now must practice the mechanics until they can also solve the sample problems in close to Rx time.  In a recent class, all but one of the students reported that they attempted the problems at least two if not three times in order to solve them in Rx time. 

\item {\bf Test mastery of the skill through an in-class, timed problem.} To assess progress toward mastery, test students on a new problem requiring the skill that they have not seen before.  Prior to class, the instructor must solve the problem to determine Rx time, and then adds 50-100\% of that time to determine DNF time.  For students to get credit for the skill, they must solve the problem both correctly and prior to the DNF time being reached.  In the unit testing example, the in-class problem Rx time was 10 minutes, and the DNF time was set at 20 minutes.  (About a quarter of the class DNF'd in a recent semester, either because they did not finish on time or did not produce a correct solution.) 

\item {\bf Move on to the next skill, typically based upon many of the same tools and technologies.} Note that the unit testing skill was based upon six underlying technologies, so it's possible to leverage the learnings from one skill in surprising way. In this example course, the skill following unit testing was basic UI design, which did not use Java, JUnit, and Checkstyle, but did use IntelliJ, git, and GitHub. 

\end{enumerate} 

In a nutshell, athletic software engineering education requires students to demonstrate mastery of the mechanics of various software engineering skillsets via timed assessments that they must complete both correctly and within a certain time limit.  We claim that this reduces distraction, improves focus, and makes learning more efficient.  

In the next section, we present initial findings from our use of these techniques in a variety of settings and student feedback.
















