\section{Athletic software engineering in a nutshell}

To understand what makes our approach ``athletic'', it helps to first consider some common approaches to software engineering education. 

{\em Lecture-based survey.}  One traditional software engineering educational model involves the study of an Introduction to Software Engineering textbook, with lectures presenting material from various chapters, and tests that assess the ability of students to define or manipulate concepts such as the ``Spiral Model'', ``White Box Testing'', ``Extreme Programming'', etc. This approach has the benefit of being both comprehensive and consistent in the way students each semester encounter the material. However, it treats software engineering material at a conceptual level and is the most susceptible to decreased learning through distraction.

{\em Project-based practicum.}  This approach involves solicitation of ```real-world'' application requirements from the surrounding community.  Students form teams and attempt to build software to satisfy their customer needs.  The project-based practicum tends to produce more engagement among many students, although the experiences encountered by each group varies a great deal based upon their community sponsor. In addition, the experience of a student within a single group can vary, and it is difficult to guarantee or assess that all students in the group are gaining the same software engineering experiences. 

{\em Flipped classroom.}  A third approach is to ``flip'' or ``invert'' the classroom. In this case, lecture material is recorded and provided to students via YouTube, leaving class time for more active learning opportunities. For example, class time can be devoted to what was traditionally ``homework'', which is how this approach became known as ``flipping''.  This approach requires students to focus on videos outside of class, which is highly susceptible to distraction.

Each of these approaches has their potential use cases, but none attempts to {\em explicitly} address the problems of distraction in modern educational environments. Put another way, how can we design the educational process to incentivize students to focus single-mindedly on the learning of complex, multi-step tasks without multi-tasking?  And if we can succeed, does that lead to more efficient and effective learning, which means that students will acquire more information in a given semester and retain it longer? 

Our approach adapts two simple features of conventional athletic training. First, time must be minimized.  Many sports (such as running, cycling, etc.) are based upon completing a task in a minimal amount of time.  Second, speed is a result of quality. To go fast, you must have good form and technique. 

Neither of these are traditionally applied to the software engineering classroom. In general, assignments are typically given out to remove time as an issue: for example, if the instructor believes a problem could be completed in a day, they might provide a week so that time is removed as a factor.  Second, working ``fast'' in software development is generally perceived as producing low quality software. Unlike athletic contexts, where fast means optimal technique, in software development, fast means sloppy technique. 

Let's take a simple example: writing a unit test.  In a lecture-based survey course, students might read a chapter about unit testing, learn how to compare and contrast it with other kinds of testing (integration testing, load testing, etc.), and demonstrate this knowledge by way of a written exam.  In a project-based practicum, students might be expected to develop running unit tests for their application, though different groups might develop their tests at different times and with different technologies. In a flipped classroom, students might learn about unit testing through video lectures at home, then come into class and develop some unit tests under the guidance of the teacher. 

In athletic software engineering education, an activity such as unit testing is recognized to consist of both ``creative'' components (deciding what to actually test and how the test should work) and ``mechanical'' components (the set of procedures to reify that idea in high quality software).  Our insight is that in modern software engineering, helping students develop fluency with the mechanical components can significantly speed up software development and thus free up time for the creative aspects. 

So, the mechanics of writing a unit test might involve testing Java abstract data types using the JUnit library, with code edited using the IntelliJ IDEA interactive development environment, and ultimately stored in GitHub. For a student to accomplish this task fluently, they must understand how to sync their local repo with GitHub, create a local branch to hold their development code, use IDEA shortcuts to create the Java class to hold the unit test and automatically import the appropriate JUnit library, use method completion to reduce the keystrokes required to create assertions, run the tests within IDEA, invoke Checkstyle to ensure that coding standards are maintained, commit the finished code to the branch, and merge the branch into master. 










